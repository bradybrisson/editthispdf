<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PDF Editor + Whiteout/Text Boxes</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; }
    #pdf-container {
      position: relative;
      border: 1px solid #ccc;
      margin-top: 1em;
      width: 600px;
      height: 800px;
      overflow: hidden;
    }
    #pdf-canvas {
      border: 1px solid black;
      display: block;
    }
    .annotation {
      position: absolute;
      box-sizing: border-box;
      resize: both;
      overflow: auto;
      user-select: text;
    }
    .whiteout, .textbox {
      cursor: move;
    }
    .whiteout {
      background: white;
      border: 1px solid #555;
      z-index: 10;
      min-width: 20px;
      min-height: 20px;
      resize: both;
      overflow: auto;
    }
    .whiteout::after {
      content: '';
      position: absolute;
      bottom: 0;
      right: 0;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-bottom: 8px solid #555;
      cursor: se-resize;
    }
    .textbox {
      border: 1px solid blue;
      background: rgba(255,255,255,0.85);
      padding: 2px 5px;
      outline: none;
      z-index: 20;
      min-width: 40px;
      min-height: 20px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      color: #000000;
    }
    .textbox.selected {
      border: 2px solid #ff6b6b;
      box-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
    }
    #controls {
      margin-bottom: 0.5em;
    }
  </style>
</head>
<body>
  <h1>Welcome to EditThisPDF.com</h1>
  <div id="controls">
    <input type="file" id="upload" accept="application/pdf" />
    <button id="add-whiteout" disabled>Add Whiteout</button>
    <button id="add-textbox" disabled>Add Text Box</button>
    <div style="display: flex; gap: 0.5em; align-items: center; margin-top: 0.5em;">
      <label for="filename">New Filename:</label>
      <input type="text" id="filename" value="edited" placeholder="Enter filename" style="width: 150px;">
      <button id="save-pdf" disabled>Save PDF</button>
    </div>
  </div>
  
  <div id="text-styling" style="display: none; margin: 1em 0; padding: 1em; border: 1px solid #ccc; background: #f9f9f9;">
    <h3>Text Styling</h3>
    <div style="display: flex; gap: 1em; align-items: center; flex-wrap: wrap;">
      <div>
        <label for="font-family">Font Family:</label>
        <select id="font-family">
          <option value="Arial">Arial</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Verdana">Verdana</option>
          <option value="Helvetica">Helvetica</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
        </select>
      </div>
      <div>
        <label for="font-size">Font Size:</label>
        <input type="number" id="font-size" value="12" min="8" max="72" style="width: 60px;">
      </div>
      <div>
        <label for="text-color">Text Color:</label>
        <input type="color" id="text-color" value="#000000">
      </div>
      <div>
        <button id="apply-styling" disabled>Apply to Selected</button>
        <button id="clear-selection">Clear Selection</button>
      </div>
    </div>
  </div>
  
  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'] || window['pdfjsLib'] || window.pdfjsLib;
    // Set worker src
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';

    const uploadInput = document.getElementById('upload');
    const addWhiteoutBtn = document.getElementById('add-whiteout');
    const addTextboxBtn = document.getElementById('add-textbox');
    const savePdfBtn = document.getElementById('save-pdf');
    const filenameInput = document.getElementById('filename');
    const pdfContainer = document.getElementById('pdf-container');
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    
    // Text styling controls
    const textStylingDiv = document.getElementById('text-styling');
    const fontFamilySelect = document.getElementById('font-family');
    const fontSizeInput = document.getElementById('font-size');
    const textColorInput = document.getElementById('text-color');
    const applyStylingBtn = document.getElementById('apply-styling');
    const clearSelectionBtn = document.getElementById('clear-selection');
    
    let selectedTextbox = null;

    let pdfDoc = null;
    let pageViewport = null;
    let scale = 1.5;

    uploadInput.addEventListener('change', async (e) => {
      console.log('File selected');
      const file = e.target.files[0];
      if (!file) {
        console.log('No file');
        return;
      }
      if (file.type !== 'application/pdf') {
        alert('Please upload a PDF file');
        return;
      }
      const arrayBuffer = await file.arrayBuffer();
      console.log('Loaded arrayBuffer, size:', arrayBuffer.byteLength);
      try {
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        pdfDoc = await loadingTask.promise;
        console.log('PDF loaded, pages:', pdfDoc.numPages);
      } catch (err) {
        console.error('Error loading PDF:', err);
        alert('Failed to load PDF');
        return;
      }

      // Render page 1
      await renderPage(1);
      addWhiteoutBtn.disabled = false;
      addTextboxBtn.disabled = false;
      savePdfBtn.disabled = false;
      // Remove previous annotations if any
      document.querySelectorAll('.annotation').forEach(el => el.remove());
    });

    async function renderPage(pageNum) {
      if (!pdfDoc) {
        console.log('No pdfDoc');
        return;
      }
      const page = await pdfDoc.getPage(pageNum);
      pageViewport = page.getViewport({ scale });

      canvas.width = pageViewport.width;
      canvas.height = pageViewport.height;
      pdfContainer.style.width = canvas.width + 'px';
      pdfContainer.style.height = canvas.height + 'px';

      const renderContext = {
        canvasContext: ctx,
        viewport: pageViewport
      };
      await page.render(renderContext).promise;
      console.log('Page rendered');
    }

    // Add Whiteout
    addWhiteoutBtn.addEventListener('click', () => {
      const wo = document.createElement('div');
      wo.className = 'annotation whiteout';
      wo.style.left = '60px';
      wo.style.top = '60px';
      wo.style.width = '150px';
      wo.style.height = '50px';
      makeDraggableResizable(wo);
      pdfContainer.appendChild(wo);
    });

    // Add Text Box
    addTextboxBtn.addEventListener('click', () => {
      const tb = document.createElement('div');
      tb.className = 'annotation textbox';
      tb.contentEditable = true;
      tb.style.left = '70px';
      tb.style.top = '70px';
      tb.style.width = '150px';
      tb.style.height = '30px';
      tb.innerText = 'Edit me';
      makeDraggableResizable(tb);
      addTextboxClickHandler(tb);
      pdfContainer.appendChild(tb);
      tb.focus();
      
      // Show styling controls when text box is added
      textStylingDiv.style.display = 'block';
    });

    // Draggable & resizable function
    function makeDraggableResizable(el) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      el.addEventListener('mousedown', (e) => {
        // Don't interfere with text editing or whiteout resizing
        if (el.classList.contains('textbox') && el.contentEditable === 'true') {
          return; // Let text editing work normally
        }
        
        // For whiteout, only drag if not on resize handle
        if (el.classList.contains('whiteout')) {
          const rect = el.getBoundingClientRect();
          const handleSize = 15;
          const isOnResizeHandle = (
            e.clientX > rect.right - handleSize && 
            e.clientY > rect.bottom - handleSize
          );
          if (isOnResizeHandle) {
            return; // Let CSS resize work
          }
        }

        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        const rect = el.getBoundingClientRect();
        const contRect = pdfContainer.getBoundingClientRect();
        startLeft = rect.left - contRect.left;
        startTop = rect.top - contRect.top;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const x = e.clientX - startX + startLeft;
        const y = e.clientY - startY + startTop;

        // Clip boundaries
        const boundedX = Math.max(0, Math.min(x, pdfContainer.clientWidth - el.offsetWidth));
        const boundedY = Math.max(0, Math.min(y, pdfContainer.clientHeight - el.offsetHeight));

        el.style.left = boundedX + 'px';
        el.style.top = boundedY + 'px';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    // Add click handler for text box selection
    function addTextboxClickHandler(textbox) {
      // Only handle selection on focus, not on mousedown
      textbox.addEventListener('focus', () => {
        selectTextbox(textbox);
      });
      
      // Handle selection when clicking outside the text content
      textbox.addEventListener('click', (e) => {
        // Only select if clicking on the border/background, not the text
        if (e.target === textbox) {
          selectTextbox(textbox);
        }
      });
    }

    // Select a text box
    function selectTextbox(textbox) {
      // Remove selection from all text boxes
      document.querySelectorAll('.textbox').forEach(tb => {
        tb.classList.remove('selected');
      });
      
      // Select the clicked text box
      textbox.classList.add('selected');
      selectedTextbox = textbox;
      
      // Update styling controls with current values
      fontFamilySelect.value = textbox.style.fontFamily || 'Arial';
      fontSizeInput.value = parseInt(textbox.style.fontSize) || 12;
      textColorInput.value = textbox.style.color || '#000000';
      
      // Enable apply button
      applyStylingBtn.disabled = false;
    }

    // Apply styling to selected text box
    applyStylingBtn.addEventListener('click', () => {
      if (selectedTextbox) {
        selectedTextbox.style.fontFamily = fontFamilySelect.value;
        selectedTextbox.style.fontSize = fontSizeInput.value + 'px';
        selectedTextbox.style.color = textColorInput.value;
      }
    });

    // Clear selection
    clearSelectionBtn.addEventListener('click', () => {
      document.querySelectorAll('.textbox').forEach(tb => {
        tb.classList.remove('selected');
      });
      selectedTextbox = null;
      applyStylingBtn.disabled = true;
    });

    // Click on PDF container to deselect
    pdfContainer.addEventListener('click', (e) => {
      if (e.target === pdfContainer) {
        document.querySelectorAll('.textbox').forEach(tb => {
          tb.classList.remove('selected');
        });
        selectedTextbox = null;
        applyStylingBtn.disabled = true;
      }
    });

    savePdfBtn.addEventListener('click', async () => {
      if (!pdfDoc) {
        alert('No PDF loaded');
        return;
      }
      const pdfBytes = await pdfDoc.getData();
      const pdfLibDoc = await PDFLib.PDFDocument.load(pdfBytes);
      const page = pdfLibDoc.getPage(0);
      const { width, height } = page.getSize();

      // Whiteouts first
      document.querySelectorAll('.whiteout').forEach(wo => {
        const left = parseFloat(wo.style.left);
        const top = parseFloat(wo.style.top);
        const w = wo.offsetWidth;
        const h = wo.offsetHeight;

        const x = (left / pdfContainer.clientWidth) * width;
        const y = height - ((top + h) / pdfContainer.clientHeight) * height;

        const rect = pdfLibDoc.getPage(0).drawRectangle({
          x, y,
          width: (w / pdfContainer.clientWidth) * width,
          height: (h / pdfContainer.clientHeight) * height,
          color: PDFLib.rgb(1,1,1),
          borderColor: PDFLib.rgb(1,1,1),
          borderWidth: 0,
          opacity: 1
        });
      });

      // Text boxes
      document.querySelectorAll('.textbox').forEach(tb => {
        const left = parseFloat(tb.style.left);
        const top = parseFloat(tb.style.top);
        const w = tb.offsetWidth;
        const h = tb.offsetHeight;
        const text = tb.innerText;

        const x = (left / pdfContainer.clientWidth) * width;
        const y = height - ((top + h) / pdfContainer.clientHeight) * height;

        // Get styling from the text box
        const fontSize = parseInt(tb.style.fontSize) || 12;
        const fontFamily = tb.style.fontFamily || 'Arial';
        const color = tb.style.color || '#000000';
        
        // Convert hex color to RGB
        const hex = color.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;

        page.drawText(text, {
          x,
          y,
          size: fontSize,
          color: PDFLib.rgb(r, g, b),
          maxWidth: (w / pdfContainer.clientWidth) * width,
          lineHeight: fontSize * 1.2
        });
      });

      const newPdfBytes = await pdfLibDoc.save();
      const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      
      // Use custom filename or default
      const filename = filenameInput.value.trim() || 'edited';
      const finalFilename = filename.endsWith('.pdf') ? filename : filename + '.pdf';
      link.download = finalFilename;
      link.click();
      
      // Clean up the object URL
      setTimeout(() => URL.revokeObjectURL(link.href), 100);
    });
  </script>
</body>
</html>
