<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF.js + Editable Annotation Demo</title>
  <style>
    #pdf-container {
      position: relative;
      border: 1px solid #ccc;
      width: 600px;
      height: 800px;
      margin-bottom: 1em;
    }
    #pdf-canvas {
      border: 1px solid black;
      display: block;
    }
    .textbox {
      position: absolute;
      border: 1px solid blue;
      background: rgba(255,255,255,0.7);
      padding: 4px;
      min-width: 100px;
      min-height: 20px;
      cursor: move;
      user-select: text;
      resize: both;
      overflow: auto;
    }
  </style>
</head>
<body>
  <h1>PDF.js + Editable Text Annotation</h1>

  <input type="file" id="upload" accept="application/pdf" />
  <button id="add-textbox" disabled>Add Text Box</button>
  <button id="save-pdf" disabled>Save PDF with Annotations</button>

  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <!-- PDF.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
  <!-- pdf-lib for saving -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];

    const uploadInput = document.getElementById('upload');
    const addTextboxBtn = document.getElementById('add-textbox');
    const savePdfBtn = document.getElementById('save-pdf');
    const pdfContainer = document.getElementById('pdf-container');
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');

    let pdfDoc = null;
    let scale = 1.5;
    let pageViewport = null;

    // Store textbox info: {x, y, width, height, content}
    let textboxes = [];

    uploadInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file || file.type !== 'application/pdf') {
        alert('Please upload a PDF file');
        return;
      }
      const arrayBuffer = await file.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

      renderPage(1);
      addTextboxBtn.disabled = false;
      savePdfBtn.disabled = false;
      textboxes = [];
      // Remove old textboxes
      document.querySelectorAll('.textbox').forEach(tb => tb.remove());
    });

    async function renderPage(pageNum) {
      const page = await pdfDoc.getPage(pageNum);
      pageViewport = page.getViewport({ scale: scale });
      canvas.width = pageViewport.width;
      canvas.height = pageViewport.height;
      pdfContainer.style.width = canvas.width + 'px';
      pdfContainer.style.height = canvas.height + 'px';

      const renderContext = {
        canvasContext: ctx,
        viewport: pageViewport
      };
      await page.render(renderContext).promise;
    }

    // Add editable text box overlay
    addTextboxBtn.addEventListener('click', () => {
      const textbox = document.createElement('div');
      textbox.contentEditable = true;
      textbox.className = 'textbox';
      textbox.style.left = '50px';
      textbox.style.top = '50px';
      textbox.style.width = '150px';
      textbox.style.height = '30px';
      textbox.textContent = 'Edit me';

      makeDraggable(textbox);

      pdfContainer.appendChild(textbox);
    });

    // Make div draggable inside container
    function makeDraggable(element) {
      let isDragging = false;
      let offsetX, offsetY;

      element.addEventListener('mousedown', e => {
        if (e.target !== element) return;
        isDragging = true;
        offsetX = e.clientX - element.getBoundingClientRect().left;
        offsetY = e.clientY - element.getBoundingClientRect().top;
        element.style.cursor = 'grabbing';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        element.style.cursor = 'move';
      });

      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        let x = e.clientX - offsetX - pdfContainer.getBoundingClientRect().left;
        let y = e.clientY - offsetY - pdfContainer.getBoundingClientRect().top;

        // Keep inside container bounds
        x = Math.max(0, Math.min(x, pdfContainer.clientWidth - element.offsetWidth));
        y = Math.max(0, Math.min(y, pdfContainer.clientHeight - element.offsetHeight));

        element.style.left = x + 'px';
        element.style.top = y + 'px';
      });
    }

    savePdfBtn.addEventListener('click', async () => {
      if (!pdfDoc) return alert('Load a PDF first');

      // Get the first page in pdf-lib format
      const pdfBytes = await pdfDoc.getData();
      const pdfLibDoc = await PDFLib.PDFDocument.load(pdfBytes);

      const page = pdfLibDoc.getPage(0);
      const { width, height } = page.getSize();

      // Collect all textboxes data relative to PDF page
      const pdfContainerRect = pdfContainer.getBoundingClientRect();

      document.querySelectorAll('.textbox').forEach(tb => {
        // Calculate text position in PDF units (bottom-left origin)
        const left = parseFloat(tb.style.left);
        const top = parseFloat(tb.style.top);
        const tbWidth = tb.offsetWidth;
        const tbHeight = tb.offsetHeight;
        const text = tb.textContent;

        // Convert from px (container) to PDF coordinates
        // PDF origin is bottom-left, browser top-left, so invert Y
        const x = (left / pdfContainer.clientWidth) * width;
        const y = height - ((top + tbHeight) / pdfContainer.clientHeight) * height;

        // Draw text on PDF page
        page.drawText(text, {
          x,
          y,
          size: 12,
          color: PDFLib.rgb(0, 0, 1),
          maxWidth: (tbWidth / pdfContainer.clientWidth) * width,
          lineHeight: 14,
        });
      });

      const newPdfBytes = await pdfLibDoc.save();

      // Download new PDF
      const blob = new Blob([newPdfBytes], {type: 'application/pdf'});
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'annotated.pdf';
      link.click();
    });
  </script>
</body>
</html>
